// src/application/schedule/GenerateScheduleFromBudgetUseCase.ts
import { CalculationBudgetRepository } from '../../domain/repositories/CalculationBudgetRepository';
import { CalculationScheduleRepository } from '../../domain/repositories/CalculationScheduleRepository';
import { ScheduleTemplateRepository } from '../../domain/repositories/ScheduleTemplateRepository';
import { ScheduleActivityRepository } from '../../domain/repositories/ScheduleActivityRepository';
import { CalculationSchedule } from '../../domain/models/calculation/CalculationSchedule';
import { ScheduleActivity, ActivityType, ActivityStatus, ActivityPriority, ConstructionTrade } from '../../domain/models/calculation/ScheduleActivity';

export interface GenerateScheduleRequest {
  budgetId: string;
  templateId?: string;
  projectStartDate: Date;
  workingDaysPerWeek?: number;
  dailyWorkingHours?: number;
  includeWeatherBuffer?: boolean;
  customActivities?: {
    name: string;
    duration: number;
    dependencies?: string[];
  }[];
}

export interface GenerateScheduleResponse {
  schedule: CalculationSchedule;
  activities: ScheduleActivity[];
  criticalPath: string[];
  estimatedCompletionDate: Date;
  totalDuration: number;
  recommendations: string[];
}

export class GenerateScheduleFromBudgetUseCase {
  constructor(
    private budgetRepository: CalculationBudgetRepository,
    private scheduleRepository: CalculationScheduleRepository,
    private templateRepository: ScheduleTemplateRepository,
    private activityRepository: ScheduleActivityRepository
  ) {}

  async execute(request: GenerateScheduleRequest): Promise<GenerateScheduleResponse> {
    // 1. Obtener el presupuesto
    const budget = await this.budgetRepository.findById(request.budgetId);
    if (!budget) {
      throw new Error('Budget not found');
    }

    // 2. Obtener template apropiado
    let template;
    if (request.templateId) {
      template = await this.templateRepository.findById(request.templateId);
    } else {
      // Buscar template por tipo de construcción y zona
      const templates = await this.templateRepository.findByFilters({
        constructionType: budget.projectType,
        geographicalZone: budget.geographicalZone,
        scope: 'SYSTEM',
        isVerified: true
      });
      template = templates[0]; // Usar el primer template verificado
    }

    if (!template) {
      throw new Error('No suitable template found');
    }

    // 3. Crear cronograma base
    const schedule = await this.createScheduleFromBudget(budget, template, request);

    // 4. Generar actividades basadas en el presupuesto
    const activities = await this.generateActivitiesFromBudget(
      budget, 
      template, 
      schedule.id, 
      request
    );

    // 5. Calcular dependencias y fechas
    const scheduledActivities = this.calculateActivityDates(activities, request.projectStartDate);

    // 6. Identificar ruta crítica
    const criticalPath = this.calculateCriticalPath(scheduledActivities);

    // 7. Generar recomendaciones
    const recommendations = this.generateRecommendations(budget, template, scheduledActivities);

    // 8. Guardar en base de datos
    await this.scheduleRepository.save(schedule);
    await this.activityRepository.saveMany(scheduledActivities);

    const estimatedCompletionDate = new Date(request.projectStartDate);
    estimatedCompletionDate.setDate(
      estimatedCompletionDate.getDate() + schedule.estimatedDurationDays
    );

    return {
      schedule,
      activities: scheduledActivities,
      criticalPath,
      estimatedCompletionDate,
      totalDuration: schedule.estimatedDurationDays,
      recommendations
    };
  }

  private async createScheduleFromBudget(budget: any, template: any, request: GenerateScheduleRequest): Promise<CalculationSchedule> {
    return {
      id: '', // Will be generated by repository
      name: `Cronograma - ${budget.name}`,
      description: `Cronograma generado automáticamente desde presupuesto`,
      status: 'DRAFT',
      constructionType: budget.projectType,
      geographicalZone: budget.geographicalZone,
      projectId: budget.projectId,
      budgetId: budget.id,
      templateId: template.id,
      totalBudget: budget.totalCost,
      estimatedDurationDays: template.estimatedDurationDays,
      plannedStartDate: request.projectStartDate,
      plannedEndDate: new Date(request.projectStartDate.getTime() + (template.estimatedDurationDays * 24 * 60 * 60 * 1000)),
      workingDaysPerWeek: request.workingDaysPerWeek || 6,
      dailyWorkingHours: request.dailyWorkingHours || 8,
      resourceConfiguration: template.standardResources,
      performanceMetrics: {
        plannedValue: budget.totalCost,
        earnedValue: 0,
        actualCost: 0,
        schedulePerformanceIndex: 1,
        costPerformanceIndex: 1,
        estimateAtCompletion: budget.totalCost
      },
      weatherConfiguration: {
        includeWeatherFactors: request.includeWeatherBuffer || true,
        bufferPercentage: 15, // 15% buffer for weather
        criticalActivitiesOnly: false
      },
      alertConfiguration: {
        delayThresholdDays: 2,
        costVarianceThreshold: 10,
        qualityCheckReminders: true,
        resourceConflictAlerts: true
      },
      customFields: {},
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }

  private async generateActivitiesFromBudget(
    budget: any, 
    template: any, 
    scheduleId: string, 
    request: GenerateScheduleRequest
  ): Promise<ScheduleActivity[]> {
    const activities: ScheduleActivity[] = [];
    
    // Crear actividades basadas en los ítems del presupuesto
    for (const lineItem of budget.lineItems || []) {
      const activity = this.createActivityFromBudgetItem(lineItem, scheduleId, template);
      activities.push(activity);
    }

    // Agregar actividades personalizadas si las hay
    if (request.customActivities) {
      for (const customActivity of request.customActivities) {
        const activity = this.createCustomActivity(customActivity, scheduleId);
        activities.push(activity);
      }
    }

    // Agregar actividades de template que no están en el presupuesto
    const templateActivities = await this.getTemplateActivities(template.id);
    for (const templateActivity of templateActivities) {
      if (!activities.find(a => a.name.toLowerCase().includes(templateActivity.name.toLowerCase()))) {
        const activity = this.createActivityFromTemplate(templateActivity, scheduleId);
        activities.push(activity);
      }
    }

    return activities;
  }

  private createActivityFromBudgetItem(lineItem: any, scheduleId: string, template: any): ScheduleActivity {
    // Determinar tipo de actividad basado en la descripción del ítem
    const activityType = this.determineActivityType(lineItem.description);
    const trade = this.determinePrimaryTrade(lineItem.description);
    
    // Calcular duración basada en cantidad y productividad
    const duration = this.calculateActivityDuration(lineItem, template);

    return {
      id: '', // Will be generated
      scheduleId,
      name: lineItem.description,
      description: `Actividad generada desde ítem de presupuesto: ${lineItem.description}`,
      status: ActivityStatus.NOT_STARTED,
      activityType,
      priority: ActivityPriority.NORMAL,
      primaryTrade: trade,
      plannedStartDate: new Date(),
      plannedEndDate: new Date(),
      plannedDurationDays: duration,
      actualStartDate: null,
      actualEndDate: null,
      actualDurationDays: 0,
      progressPercentage: 0,
      plannedTotalCost: lineItem.totalCost,
      actualTotalCost: 0,
      workQuantities: {
        plannedQuantity: lineItem.quantity,
        completedQuantity: 0,
        unit: lineItem.unit
      },
      qualityRequirements: [],
      safetyRequirements: [],
      deliverables: [lineItem.description],
      predecessors: [],
      successors: [],
      resourceRequirements: this.calculateResourceRequirements(lineItem, template),
      isCriticalPath: false,
      bufferDays: 0,
      customFields: {
        budgetLineItemId: lineItem.id,
        materialCost: lineItem.materialCost,
        laborCost: lineItem.laborCost
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }

  private determineActivityType(description: string): ActivityType {
    const desc = description.toLowerCase();
    
    if (desc.includes('excavación') || desc.includes('movimiento de tierra')) {
      return ActivityType.EXCAVATION;
    } else if (desc.includes('fundación') || desc.includes('cimiento')) {
      return ActivityType.FOUNDATION;
    } else if (desc.includes('estructura') || desc.includes('columnas') || desc.includes('vigas')) {
      return ActivityType.STRUCTURE;
    } else if (desc.includes('mampostería') || desc.includes('paredes') || desc.includes('muros')) {
      return ActivityType.MASONRY;
    } else if (desc.includes('techo') || desc.includes('cubierta')) {
      return ActivityType.ROOFING;
    } else if (desc.includes('eléctrico') || desc.includes('electricidad')) {
      return ActivityType.ELECTRICAL;
    } else if (desc.includes('plomería') || desc.includes('sanitarios') || desc.includes('agua')) {
      return ActivityType.PLUMBING;
    } else if (desc.includes('acabado') || desc.includes('pintura') || desc.includes('piso')) {
      return ActivityType.FINISHING;
    } else if (desc.includes('limpieza')) {
      return ActivityType.CLEANUP;
    }
    
    return ActivityType.OTHER;
  }

  private determinePrimaryTrade(description: string): ConstructionTrade {
    const desc = description.toLowerCase();
    
    if (desc.includes('albañil') || desc.includes('mampostería')) {
      return ConstructionTrade.MASONRY;
    } else if (desc.includes('eléctrico') || desc.includes('electricista')) {
      return ConstructionTrade.ELECTRICAL;
    } else if (desc.includes('plomero') || desc.includes('plomería')) {
      return ConstructionTrade.PLUMBING;
    } else if (desc.includes('carpintero') || desc.includes('madera')) {
      return ConstructionTrade.CARPENTRY;
    } else if (desc.includes('pintor') || desc.includes('pintura')) {
      return ConstructionTrade.PAINTING;
    } else if (desc.includes('soldador') || desc.includes('hierro')) {
      return ConstructionTrade.WELDING;
    }
    
    return ConstructionTrade.GENERAL;
  }

  private calculateActivityDuration(lineItem: any, template: any): number {
    // Buscar productividad en el template
    const workforce = template.standardResources?.workforce || {};
    const trade = this.determinePrimaryTrade(lineItem.description);
    
    const tradeConfig = workforce[trade.toLowerCase()];
    if (tradeConfig && tradeConfig.productivity) {
      // Duración = cantidad / (productividad * trabajadores * horas diarias)
      const workersPerDay = tradeConfig.minWorkers;
      const dailyProductivity = tradeConfig.productivity * workersPerDay;
      return Math.ceil(lineItem.quantity / dailyProductivity);
    }
    
    // Estimación por defecto basada en costo
    // Actividades más caras generalmente toman más tiempo
    const costRatio = lineItem.totalCost / 1000; // Ajustar según moneda
    return Math.max(1, Math.ceil(costRatio * 0.5)); // Mínimo 1 día
  }

  private calculateResourceRequirements(lineItem: any, template: any): any {
    const trade = this.determinePrimaryTrade(lineItem.description);
    const workforce = template.standardResources?.workforce || {};
    const tradeConfig = workforce[trade.toLowerCase()];
    
    return {
      workforce: tradeConfig ? [
        {
          trade: trade,
          quantity: tradeConfig.minWorkers,
          hourlyRate: tradeConfig.hourlyRate,
          totalHours: tradeConfig.dailyHours
        }
      ] : [],
      equipment: [],
      materials: [
        {
          description: lineItem.description,
          quantity: lineItem.quantity,
          unit: lineItem.unit,
          unitCost: lineItem.unitCost
        }
      ]
    };
  }

  private createCustomActivity(customActivity: any, scheduleId: string): ScheduleActivity {
    return {
      id: '', // Will be generated
      scheduleId,
      name: customActivity.name,
      description: `Actividad personalizada: ${customActivity.name}`,
      status: ActivityStatus.NOT_STARTED,
      activityType: ActivityType.OTHER,
      priority: ActivityPriority.NORMAL,
      primaryTrade: ConstructionTrade.GENERAL,
      plannedStartDate: new Date(),
      plannedEndDate: new Date(),
      plannedDurationDays: customActivity.duration,
      actualStartDate: null,
      actualEndDate: null,
      actualDurationDays: 0,
      progressPercentage: 0,
      plannedTotalCost: 0,
      actualTotalCost: 0,
      workQuantities: {
        plannedQuantity: 1,
        completedQuantity: 0,
        unit: 'global'
      },
      qualityRequirements: [],
      safetyRequirements: [],
      deliverables: [customActivity.name],
      predecessors: customActivity.dependencies || [],
      successors: [],
      resourceRequirements: { workforce: [], equipment: [], materials: [] },
      isCriticalPath: false,
      bufferDays: 0,
      customFields: { isCustomActivity: true },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }

  private async getTemplateActivities(templateId: string): Promise<any[]> {
    // Implementar lógica para obtener actividades del template
    // Por ahora retornamos array vacío
    return [];
  }

  private createActivityFromTemplate(templateActivity: any, scheduleId: string): ScheduleActivity {
    return {
      id: '', // Will be generated
      scheduleId,
      name: templateActivity.name,
      description: templateActivity.description,
      status: ActivityStatus.NOT_STARTED,
      activityType: templateActivity.type || ActivityType.OTHER,
      priority: ActivityPriority.NORMAL,
      primaryTrade: templateActivity.primaryTrade || ConstructionTrade.GENERAL,
      plannedStartDate: new Date(),
      plannedEndDate: new Date(),
      plannedDurationDays: templateActivity.estimatedDurationDays,
      actualStartDate: null,
      actualEndDate: null,
      actualDurationDays: 0,
      progressPercentage: 0,
      plannedTotalCost: templateActivity.estimatedCost || 0,
      actualTotalCost: 0,
      workQuantities: {
        plannedQuantity: 1,
        completedQuantity: 0,
        unit: 'global'
      },
      qualityRequirements: templateActivity.qualityChecks || [],
      safetyRequirements: templateActivity.safetyRequirements ? [templateActivity.safetyRequirements] : [],
      deliverables: templateActivity.deliverables?.map((d: any) => d.name) || [],
      predecessors: templateActivity.predecessors || [],
      successors: templateActivity.successors || [],
      resourceRequirements: templateActivity.requiredResources || { workforce: [], equipment: [], materials: [] },
      isCriticalPath: false,
      bufferDays: Math.ceil(templateActivity.estimatedDurationDays * (templateActivity.bufferPercentage || 0) / 100),
      customFields: { fromTemplate: true },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }

  private calculateActivityDates(activities: ScheduleActivity[], startDate: Date): ScheduleActivity[] {
    // Ordenar actividades por dependencias (topological sort)
    const sortedActivities = this.topologicalSort(activities);
    
    let currentDate = new Date(startDate);
    
    for (const activity of sortedActivities) {
      // Calcular fecha de inicio basada en predecesores
      const startDateForActivity = this.calculateEarliestStartDate(activity, sortedActivities, currentDate);
      
      activity.plannedStartDate = startDateForActivity;
      
      // Calcular fecha de fin
      const endDate = new Date(startDateForActivity);
      endDate.setDate(endDate.getDate() + activity.plannedDurationDays);
      activity.plannedEndDate = endDate;
      
      // Actualizar fecha actual si esta actividad termina más tarde
      if (endDate > currentDate) {
        currentDate = new Date(endDate);
      }
    }
    
    return sortedActivities;
  }

  private topologicalSort(activities: ScheduleActivity[]): ScheduleActivity[] {
    // Implementación simple de topological sort
    const sorted: ScheduleActivity[] = [];
    const visited = new Set<string>();
    const temp = new Set<string>();
    
    const visit = (activity: ScheduleActivity) => {
      if (temp.has(activity.id)) {
        throw new Error('Circular dependency detected');
      }
      if (visited.has(activity.id)) {
        return;
      }
      
      temp.add(activity.id);
      
      // Visitar predecesores primero
      for (const predId of activity.predecessors) {
        const pred = activities.find(a => a.id === predId);
        if (pred) {
          visit(pred);
        }
      }
      
      temp.delete(activity.id);
      visited.add(activity.id);
      sorted.push(activity);
    };
    
    for (const activity of activities) {
      if (!visited.has(activity.id)) {
        visit(activity);
      }
    }
    
    return sorted;
  }

  private calculateEarliestStartDate(
    activity: ScheduleActivity, 
    allActivities: ScheduleActivity[], 
    projectStartDate: Date
  ): Date {
    let earliestStart = new Date(projectStartDate);
    
    for (const predId of activity.predecessors) {
      const predecessor = allActivities.find(a => a.id === predId);
      if (predecessor && predecessor.plannedEndDate) {
        const predEndDate = new Date(predecessor.plannedEndDate);
        if (predEndDate > earliestStart) {
          earliestStart = predEndDate;
        }
      }
    }
    
    return earliestStart;
  }

  private calculateCriticalPath(activities: ScheduleActivity[]): string[] {
    // Implementación simplificada del Critical Path Method
    const criticalPath: string[] = [];
    
    // Calcular forward pass (earliest times)
    for (const activity of activities) {
      // Ya calculado en calculateActivityDates
    }
    
    // Calcular backward pass (latest times) 
    const projectEndDate = Math.max(...activities.map(a => a.plannedEndDate.getTime()));
    
    for (let i = activities.length - 1; i >= 0; i--) {
      const activity = activities[i];
      // Calcular latest start/finish dates
      // Si total slack = 0, está en ruta crítica
      if (this.calculateTotalSlack(activity, activities) === 0) {
        activity.isCriticalPath = true;
        criticalPath.unshift(activity.id);
      }
    }
    
    return criticalPath;
  }

  private calculateTotalSlack(activity: ScheduleActivity, allActivities: ScheduleActivity[]): number {
    // Simplified slack calculation
    // Total Slack = Latest Start - Earliest Start
    // Por ahora retornamos 0 para simplificar
    return 0;
  }

  private generateRecommendations(budget: any, template: any, activities: ScheduleActivity[]): string[] {
    const recommendations: string[] = [];
    
    // Recomendación por duración total
    const totalDuration = Math.max(...activities.map(a => a.plannedEndDate.getTime())) - 
                         Math.min(...activities.map(a => a.plannedStartDate.getTime()));
    const durationDays = totalDuration / (24 * 60 * 60 * 1000);
    
    if (durationDays > template.estimatedDurationDays * 1.2) {
      recommendations.push('El cronograma generado excede la duración estimada del template en más del 20%. Considere revisar las dependencias y duraciones de actividades.');
    }
    
    // Recomendación por actividades críticas
    const criticalActivities = activities.filter(a => a.isCriticalPath);
    if (criticalActivities.length > activities.length * 0.3) {
      recommendations.push('Más del 30% de las actividades están en la ruta crítica. Considere paralelizar actividades o agregar recursos.');
    }
    
    // Recomendación por recursos
    const resourceConflicts = this.detectResourceConflicts(activities);
    if (resourceConflicts.length > 0) {
      recommendations.push(`Se detectaron ${resourceConflicts.length} conflictos de recursos. Revise la asignación de personal y equipos.`);
    }
    
    return recommendations;
  }

  private detectResourceConflicts(activities: ScheduleActivity[]): any[] {
    // Simplified resource conflict detection
    return [];
  }
}